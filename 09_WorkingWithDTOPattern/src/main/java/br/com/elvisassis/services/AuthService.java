package br.com.elvisassis.services;import br.com.elvisassis.data.dto.PersonDTO;import br.com.elvisassis.data.dto.security.AccountCredentialsDTO;import br.com.elvisassis.data.dto.security.TokenDTO;import br.com.elvisassis.exception.RequiredObjectIsNullException;import br.com.elvisassis.model.Person;import br.com.elvisassis.repository.UserRepository;import br.com.elvisassis.security.jwt.JwtTokenProvider;import lombok.extern.slf4j.Slf4j;import org.springframework.http.ResponseEntity;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.security.crypto.password.DelegatingPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.security.crypto.password.Pbkdf2PasswordEncoder;import org.springframework.stereotype.Service;import java.util.HashMap;import java.util.Map;@Slf4j@Servicepublic class AuthService {    public AuthService(AuthenticationManager authenticationManager, JwtTokenProvider tokenProvider, UserRepository repository) {        this.authenticationManager = authenticationManager;        this.tokenProvider = tokenProvider;        this.repository = repository;    }    private AuthenticationManager authenticationManager;    private JwtTokenProvider tokenProvider;    private UserRepository repository;    public ResponseEntity<TokenDTO> sigIn(AccountCredentialsDTO credentials) {        authenticationManager.authenticate(                new UsernamePasswordAuthenticationToken(                        credentials.getUsername(),                        credentials.getPassword()                )        );        var user = repository.findByUserName(credentials.getUsername());        if (user == null) throw new UsernameNotFoundException("Username " + credentials.getUsername() + " not found");        var token = tokenProvider.createAccessToken(                credentials.getUsername(),                user.getRoles()        );        return ResponseEntity.ok(token);    }    public ResponseEntity<TokenDTO> refreshToken(String username, String refreshToken) {        var user = repository.findByUserName(username);        TokenDTO token;        if (user != null) {            token = tokenProvider.refreshToken(refreshToken);        } else {            throw new UsernameNotFoundException("Username " + username + " not found!");        }        return ResponseEntity.ok(token);    }//    public AccountCredentialsDTO create(PersonDTO personDto) {////        if (personDto == null) throw new RequiredObjectIsNullException();////        log.info("Creating one User!");////        Person entity = personDto.toEntity();//        var dto = repository.save(entity).toDto();//        addHateoasLinks(dto);//        return dto;//    }    private String genereteHashedPassword(String password) {        PasswordEncoder pbkdf2Encoder = new Pbkdf2PasswordEncoder("",                8, 18500,                Pbkdf2PasswordEncoder.SecretKeyFactoryAlgorithm.PBKDF2WithHmacSHA256);        Map<String, PasswordEncoder> encoders = new HashMap<>();        encoders.put("pbkdf2", pbkdf2Encoder);        DelegatingPasswordEncoder passwordEncoder = new DelegatingPasswordEncoder("pbkdf2", encoders);        passwordEncoder.setDefaultPasswordEncoderForMatches(pbkdf2Encoder);        return passwordEncoder.encode(password);    }}