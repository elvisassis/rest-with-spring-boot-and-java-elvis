package br.com.elvisassis.integrationtests.controllers.cors.withjson;import br.com.elvisassis.config.TestConfigs;import br.com.elvisassis.integrationtests.dto.AccountCredentialsDTO;import br.com.elvisassis.integrationtests.dto.PersonDTO;import br.com.elvisassis.integrationtests.dto.TokenDTO;import br.com.elvisassis.integrationtests.testconstainers.AbstractIntegrationTest;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.DeserializationFeature;import com.fasterxml.jackson.databind.ObjectMapper;import io.restassured.builder.RequestSpecBuilder;import io.restassured.filter.log.LogDetail;import io.restassured.filter.log.RequestLoggingFilter;import io.restassured.filter.log.ResponseLoggingFilter;import io.restassured.specification.RequestSpecification;import lombok.extern.slf4j.Slf4j;import org.junit.Assert;import org.junit.jupiter.api.*;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.boot.test.web.server.LocalServerPort;import org.springframework.http.MediaType;import static io.restassured.RestAssured.given;import static junit.framework.TestCase.assertEquals;import static junit.framework.TestCase.assertNotNull;import static junit.framework.TestCase.assertTrue;@Slf4j@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)@TestMethodOrder(MethodOrderer.OrderAnnotation.class)class PersonControllerCorsTest extends AbstractIntegrationTest {    @LocalServerPort    private int port;    private static RequestSpecification specification;    private static ObjectMapper objectMapper;    private static PersonDTO person;    private static TokenDTO tokenDTO;    @BeforeAll    static void setUp() {        objectMapper = new ObjectMapper();        objectMapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);        person = new PersonDTO();        tokenDTO = new TokenDTO();    }    @Test    @Order(1)    void sigin() {        AccountCredentialsDTO credentials =                new AccountCredentialsDTO("leandro", "admin123");        tokenDTO = given()                .basePath("/auth/signin")                .port(TestConfigs.SERVER_PORT)                .contentType(MediaType.APPLICATION_JSON_VALUE)                .body(credentials)                .when()                .post()                .then()                .statusCode(200)                .extract()                .body()                .as(TokenDTO.class);        Assert.assertNotNull(tokenDTO.getAccessToken());        Assert.assertNotNull(tokenDTO.getRefreshToken());    }    @Test    @Order(2)    void create() throws JsonProcessingException {        mockPerson();        specification = new RequestSpecBuilder()                .addHeader(TestConfigs.HEADER_PARAM_ORIGIN, TestConfigs.ORIGIN_ERUDIO)                .addHeader(TestConfigs.HEADER_PARAM_AUTHORIZATION, "Bearer " + tokenDTO.getAccessToken())                .setBasePath("/api/person/v1")                .setPort(8888)                .addFilter(new RequestLoggingFilter(LogDetail.ALL))                .addFilter(new ResponseLoggingFilter(LogDetail.ALL))                .build();        var content = given(specification)                .contentType(MediaType.APPLICATION_JSON_VALUE)                    .body(person)                .when()                    .post()                .then()                .   statusCode(201)                .extract()                    .body()                        .asString();        PersonDTO createPerson = objectMapper.readValue(content, PersonDTO.class);        person = createPerson;        assertNotNull(createPerson.getId());        assertNotNull(createPerson.getFirstName());        assertNotNull(createPerson.getLastName());        assertNotNull(createPerson.getAddress());        assertNotNull(createPerson.getAddress());        assertTrue(createPerson.getId() > 0);        assertEquals("Elvis", createPerson.getFirstName());        assertEquals("Assis", createPerson.getLastName());        assertEquals("Rosário do Rio Grando - Minas Gerais - Brasil", createPerson.getAddress());        assertEquals("Male", createPerson.getGender());        assertTrue(createPerson.getEnabled());    }    @Test    @Order(3)    void createWithWrongOrigin() throws JsonProcessingException {        specification = new RequestSpecBuilder()                .addHeader(TestConfigs.HEADER_PARAM_ORIGIN, TestConfigs.ORIGIN_SEMERU)                .addHeader(TestConfigs.HEADER_PARAM_AUTHORIZATION, "Bearer " + tokenDTO.getAccessToken())                .setBasePath("/api/person/v1")                .setPort(port)                .addFilter(new RequestLoggingFilter(LogDetail.ALL))                .addFilter(new ResponseLoggingFilter(LogDetail.ALL))                .build();        var content = given(specification)                .contentType(MediaType.APPLICATION_JSON_VALUE)                    .body(person)                .when()                    .post()                .then()                    .statusCode(403)                .extract()                    .body()                        .asString();        assertEquals("Invalid CORS request", content);    }    @Test    @Order(4)    void findById() throws JsonProcessingException {        specification = new RequestSpecBuilder()                .addHeader(TestConfigs.HEADER_PARAM_ORIGIN, TestConfigs.ORIGIN_LOCAL)                .addHeader(TestConfigs.HEADER_PARAM_AUTHORIZATION, "Bearer " + tokenDTO.getAccessToken())                .setBasePath("/api/person/v1")                .setPort(TestConfigs.SERVER_PORT)                .addFilter(new RequestLoggingFilter(LogDetail.ALL))                .addFilter(new ResponseLoggingFilter(LogDetail.ALL))                .build();        var content = given(specification)                .contentType(MediaType.APPLICATION_JSON_VALUE)                    .pathParam("id", person.getId())                .when()                .   get("{id}")                .then()                    .statusCode(200)                .extract()                    .body()                        .asString();        PersonDTO createdPerson = objectMapper.readValue(content, PersonDTO.class);        person = createdPerson;        assertNotNull(createdPerson.getId());        assertNotNull(createdPerson.getFirstName());        assertNotNull(createdPerson.getLastName());        assertNotNull(createdPerson.getAddress());        assertNotNull(createdPerson.getGender());        assertTrue(createdPerson.getId() > 0);        assertEquals("Elvis", createdPerson.getFirstName());        assertEquals("Assis", createdPerson.getLastName());        assertEquals("Rosário do Rio Grando - Minas Gerais - Brasil", createdPerson.getAddress());        assertEquals("Male", createdPerson.getGender());        assertTrue(createdPerson.getEnabled());    }    @Test    @Order(5)    void findByIdWithWrongOrigin() throws JsonProcessingException {        specification = new RequestSpecBuilder()                .addHeader(TestConfigs.HEADER_PARAM_ORIGIN, TestConfigs.ORIGIN_SEMERU)                .addHeader(TestConfigs.HEADER_PARAM_AUTHORIZATION, "Bearer " + tokenDTO.getAccessToken())                .setBasePath("/api/person/v1")                .setPort(TestConfigs.SERVER_PORT)                .addFilter(new RequestLoggingFilter(LogDetail.ALL))                .addFilter(new ResponseLoggingFilter(LogDetail.ALL))                .build();        var content = given(specification)                .contentType(MediaType.APPLICATION_JSON_VALUE)                    .pathParam("id", person.getId())                .when()                    .get("{id}")                .then()                    .statusCode(403)                .extract()                    .body()                        .asString();        assertEquals("Invalid CORS request", content);    }    private void mockPerson() {        person.setFirstName("Elvis");        person.setLastName("Assis");        person.setAddress("Rosário do Rio Grando - Minas Gerais - Brasil");        person.setGender("Male");        person.setEnabled(true);    }}